{
  "permissions": {
    "allow": [
      "Bash(ls:*)",
      "Bash(python:*)",
      "Bash(C:ProgramDataminiconda3envsdashpython.exe -c \"import sys; print\\(sys.version\\)\")",
      "Bash(conda activate:*)",
      "Bash(\"/c/ProgramData/miniconda3/envs/dash/python.exe\" --version)",
      "Bash(\"/c/ProgramData/miniconda3/envs/dash/python.exe\" test_buffer_rapido.py)",
      "Bash(\"/c/ProgramData/miniconda3/envs/dash/python.exe\" -c \"\nimport duckdb\nimport time\nimport concurrent.futures\nimport threading\nfrom datetime import datetime\nimport random\nimport os\n\nclass Buffer:\n    def __init__\\(self, db, interval\\):\n        self.conn = duckdb.connect\\(db\\)\n        self.interval = interval\n        self.sync_count = 0\n        self.sync_log = []\n        self.stop = False\n        self.conn.execute\\(''CREATE TABLE IF NOT EXISTS asist \\(id VARCHAR, rut VARCHAR, sync BOOLEAN DEFAULT false\\)''\\)\n        threading.Thread\\(target=self._sync_loop, daemon=True\\).start\\(\\)\n    \n    def marcar\\(self, rut\\):\n        inicio = time.time\\(\\)\n        self.conn.execute\\(''INSERT INTO asist VALUES \\(?, ?, false\\)'', [f''ID-{time.time\\(\\)}'', rut]\\)\n        return \\(time.time\\(\\) - inicio\\) * 1000\n    \n    def _sync_loop\\(self\\):\n        while not self.stop:\n            time.sleep\\(self.interval\\)\n            inicio_sync = time.time\\(\\)\n            pendientes = self.conn.execute\\(''SELECT id FROM asist WHERE sync = false LIMIT 50''\\).fetchall\\(\\)\n            if pendientes:\n                for p in pendientes:\n                    time.sleep\\(0.05\\)  # Simular API\n                    self.conn.execute\\(''UPDATE asist SET sync = true WHERE id = ?'', [p[0]]\\)\n                duracion = time.time\\(\\) - inicio_sync\n                self.sync_count += 1\n                self.sync_log.append\\({''ciclo'': self.sync_count, ''count'': len\\(pendientes\\), ''duracion'': duracion}\\)\n                print\\(f''[Sync #{self.sync_count}] {len\\(pendientes\\)} registros en {duracion:.2f}s''\\)\n    \n    def stats\\(self\\):\n        total = self.conn.execute\\(''SELECT COUNT\\(*\\) FROM asist''\\).fetchone\\(\\)[0]\n        sync = self.conn.execute\\(''SELECT COUNT\\(*\\) FROM asist WHERE sync = true''\\).fetchone\\(\\)[0]\n        return total, sync\n\nprint\\(''\\\\n=== SIMULACION: 50 usuarios, sync cada 5s ===\\\\n''\\)\nbuf = Buffer\\(''test_sim5.db'', 5\\)\n\nprint\\(''Registrando 50 usuarios...''\\)\ninicio = time.time\\(\\)\nwith concurrent.futures.ThreadPoolExecutor\\(50\\) as ex:\n    tiempos = list\\(ex.map\\(lambda i: buf.marcar\\(f''RUT-{i}''\\), range\\(50\\)\\)\\)\nprint\\(f''Completado en {time.time\\(\\)-inicio:.2f}s''\\)\nprint\\(f''Promedio escritura: {sum\\(tiempos\\)/len\\(tiempos\\):.2f}ms\\\\n''\\)\n\ntotal, sync = buf.stats\\(\\)\nprint\\(f''Total: {total}, Sync: {sync}, Pendientes: {total-sync}\\\\n''\\)\n\nprint\\(''Esperando 30s para sincronizacion...\\\\n''\\)\nfor i in range\\(30\\):\n    time.sleep\\(1\\)\n    if \\(i+1\\) % 5 == 0:\n        total, sync = buf.stats\\(\\)\n        print\\(f''T+{i+1}s: Sync={sync}/{total}''\\)\n\ntotal, sync = buf.stats\\(\\)\nprint\\(f''\\\\nRESULTADOS FINALES:''\\)\nprint\\(f''  Sincronizados: {sync}/{total} \\({sync/total*100:.1f}%\\)''\\)\nprint\\(f''  Ciclos de sync: {buf.sync_count}''\\)\n\nif buf.sync_log:\n    total_tiempo = sum\\(l[''duracion''] for l in buf.sync_log\\)\n    print\\(f''  Tiempo total sync: {total_tiempo:.2f}s''\\)\n    print\\(f''  Tiempo promedio/ciclo: {total_tiempo/len\\(buf.sync_log\\):.2f}s''\\)\n\nbuf.stop = True\n\")"
    ]
  }
}
